## 1. Доказательство
Пусть $\forall n, m \in \mathbb{Z}$ числа вида $n+m$ и $m^2+n^2+1$ покрашены в один цвет


**Шаг 1:** 
Два числа $m_1^2+n_1^2+1$ =  $m_2^2+n_2^2+1 \iff m_{1,2}=\alpha k \pm \beta, n_{1,2}=\beta k \mp \alpha$:

$$m_1^2 + n_1^2 = (\alpha k + \beta)^2+(\beta k - \alpha)^2 = $$
$$ = (\alpha^2 k^2 + 2 \alpha \beta k + \beta^2)+(\beta^2 k^2 -2\alpha\beta k + \alpha^2) = $$
$$ = (\alpha k - \beta)^2+(\beta k + \alpha)^2 = m_2^2 + n_2^2$$

Следовательно, для чисел вида $m_{1,2}=\alpha k \pm \beta, n_{1,2}=\beta k \mp \alpha$ в один цвет покрашены числа $m_1^2+n_1^2+1, m_2^2+n_2^2+1$ и $m_1+n_1, m_2+n_2$ в соответствии с изначальным предположением.

**Шаг 2:** Рассмотрим произвольное $N>0$ и все пары чисел $a<b \le N$. 
Сконструируем последовательности $\{a_i\}, \{b_j\}$ следующим образом:

$$ a_i = m_i^a + b_i^a $$
$$ a_{i+1} = (m_i^a)^2 + (b_i^a)^2+1 $$

Аналогично задаются $b_j$.
 
На некотором шаге последовательности, по результатам шага 1: $(m_t^a)^2 + (b_t^a)^2+1=(m_s^b)^2 + (b_s^b)^2+1$

Таким образом, что $a_{t+1}$ и $b_{s+1}$ окрашены в 1 цвет, а из построения $\{a_i\}, \{b_j\}$ следует, что так же окрашены и все $a_i, b_j,\quad i=\overline{1, t},\quad j=\overline{1, s}$

Получили: все пары чисел $a<b \le N$ окрашены в 1 цвет.
Так как пары получены сочетаниями без повторений из $N$ элементов, следовательно, все $n \le N$ окрашены в 1 цвет.

Из произвольности $N$ следует, что утвеждение верно $\forall n \in \mathbb{Z}$

## 2. Реализация на Python

### Методы `iterate` и `get_path`

Методы реализуют алгоритм рекурсивного поиска общих значений для двух начальных чисел (`a` и `b`), таких что каждая последовательность $\{a_i\}, \{b_j\}$ формируется, как приведено в доказательстве выше:  

1. На каждом шаге для числа вычисляются все возможные пары `(m, n)`, удовлетворяющие уравнению:  
    $$ a_i = m_i^a + b_i^a $$
    $$ a_{i+1} = (m_i^a)^2 + (b_i^a)^2+1 $$
   Аналогично для `b`.

2. Рекурсия продолжается до тех пор, пока одно из следующих условий не выполнится:  
   - Достигнута максимальная глубина рекурсии.
   - Значения для `a` и `b` не превышают установленной верхней границы (во избежание переполнения памяти).  

#### `iterate`

Рекурсивно вычисляет последовательность значений для заданного числа `a`, сохраняя как промежуточные результаты, так и пути, которые привели к ним.

##### Аргументы:
- `a` (`int`): Начальное значение последовательности.
- `values_a` (`list`): Список всех значений, которые принимает `a` в процессе итерации.
- `list_a` (`list`): Список значений вместе с путями (каждый путь представлен как список объектов `NumbersStep`).
- `path` (`list`): Текущий путь до значения `a`.
- `depth` (`int`, необязательный): Текущая глубина рекурсии. По умолчанию `0`.
- `max_depth` (`int`, необязательный): Максимальная глубина рекурсии. Определяет ограничение на длину последовательности. По умолчанию `3`.

##### Пример вызова:
```python
checker.iterate(10, values_a=[10], list_a=[[10, []]], path=[], max_depth=5)
```

##### Основные операции:
- Генерирует все пары `(m, n)` для текущего значения `a`.
- Вычисляет следующее значение `next_value` по формуле:  
  $$
  next\_value = m^2 + n^2 + 1
  $$
- Рекурсивно вызывает себя для `next_value`.

##### Проблемы и варианты улучшений:
1. Подобранные пороговое значение, а также глубина рекурсии не всегда позволяют расчитать пересекающие значения для $a_i$ и $b_i$ (в частности, по этой причине не проходит тест `test_correct_path(N=10)`). 

Решением этой проблемы может послужить избавление от рекурсивного поиска, замена его на цикл, на каждом шаге которого будут находиться новые итерации значений $a_i$ и $b_i$ и проверяться их пересечение. При нахождении пересечения цикл будет завершаться.

---

#### `get_path`

Находит минимальное общее значение для двух последовательностей, начинающихся с `a` и `b`, а также пути, которые привели к этому значению.

##### Аргументы:
- `a` (`int`): Начальное значение первой последовательности.
- `b` (`int`): Начальное значение второй последовательности.

##### Возвращаемое значение:
Объект `NumbersPath`, содержащий:
- Начальные значения `a` и `b`.
- Пути для обоих чисел в виде списка объектов `NumbersStep`.

##### Пример вызова:
```python
path = checker.get_path(10, 15)
print(path)
```

##### Основные операции:
1. Вызывает `iterate` для обоих чисел, чтобы построить их последовательности и пути.
2. Находит минимальное общее значение между последовательностями значений `a` и `b`.
3. Формирует объект `NumbersPath` с соответствующими путями.
