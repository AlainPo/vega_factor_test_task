## 1. Доказательство

**Утверждение:** Пусть $\forall n, m \in \mathbb{Z}$ числа вида $n + m$ и $m^2 + n^2 + 1$ покрашены в один цвет. Тогда все $n \in \mathbb{N}$ окрашены в один цвет.



**Шаг 1: Свойство чисел вида $m^2 + n^2 + 1$**

Покажем, что если $m_1^2 + n_1^2 + 1 = m_2^2 + n_2^2 + 1$, то $m_1, n_1$ и $m_2, n_2$ связаны линейным преобразованием:

$$m_1 = \alpha k \pm \beta, \quad n_1 = \beta k \mp \alpha.$$

 
Пусть $m_1^2 + n_1^2 = m_2^2 + n_2^2$. Тогда:

$$m_1^2 + n_1^2 = (\alpha k + \beta)^2 + (\beta k - \alpha)^2 = (\alpha^2 k^2 + 2\alpha\beta k + \beta^2) + (\beta^2 k^2 - 2\alpha\beta k + \alpha^2),$$

что идентично выражению для $m_2^2 + n_2^2$. 

Значит, соответствующие числа $m^2 + n^2 + 1$ действительно равны, и все числа вида $n + m$, $m^2 + n^2 + 1$ для таких $m, n$ покрашены в один цвет.


**Шаг 2: Конструкция последовательностей $\{a_i\}$ и $\{b_j\}$**

Рассмотрим числа $a$ и $b$. Построим рекурсивные последовательности:

$$a_i = m_i^a + n_i^a, \quad a_{i+1} = (m_i^a)^2 + (n_i^a)^2 + 1,$$

и аналогично для $b_j$.

Чтобы доказать, что пересечение последовательностей $\{a_i\}$ и $\{b_j\}$ всегда существует, воспользуемся следующим:

1. *Возрастание последовательностей:*  
   Каждая из последовательностей $\{a_i\}$ и $\{b_j\}$ строго возрастает, так как $m^2 + n^2 + 1 > m + n$ для любых $m, n \geq 0$.
   
2. *Отсутствие цикличности:*  
   Если последовательность зацикливается, то числа $m, n$ фиксируются, что противоречит возрастанию $m^2 + n^2 + 1 > m + n$.

3. *Ограничение классов вычетов:*  
   Множество всех чисел вида $m^2 + n^2 + 1$ ограничено в $mod \ 4$:  
   - $m^2 + n^2$ всегда даёт $0, 1, 2$ при делении на 4.  
   - Добавление 1 даёт возможные остатки $1, 2, 3$.  
   
   Это означает, что числа в $\{a_i\}$ и $\{b_j\}$ принадлежат конечному числу классов вычетов по модулю 4, что предотвращает "расхождение" последовательностей.
   
Значит, для достаточно больших $i$ и $j$ найдутся такие $a_{i+1}= b_{j+1}$, где $a_i = (m_i^a)^2 + (n_i^a)^2 + 1 = (m_j^b)^2 + (n_j^b)^2 + 1$.

Пересечение последовательностей показывает, что любое число $n \in \mathbb{N}$ связано с любым другим через цепочку последовательностей, поэтому они окрашиваются в один цвет.

**Шаг 3: Все числа покрыты**

Теперь докажем, что всякое число $n \in \mathbb{N}$ встречается в какой-либо последовательности.  
1. Для любого числа $n$, можем выбрать пару $(m, n)=(0, n)$, такую что $n + m = n + 0 = n$.  
2. Рекурсивно вычисляя $m^2 + n^2 + 1$, мы генерируем все числа, которые могут быть представлены в виде суммы квадратов с добавлением 1.  

**Шаг 4: Вывод**

Так как каждая последовательность пересекается с любой другой за конечное число шагов, и любая последовательность покрывает все числа $n \in \mathbb{N}$, то все числа $n$ окрашены в один цвет.


## 2. Реализация на Python

Методы класса `Checker` реализуют алгоритм поиска пересечения последовательностей чисел, где каждое следующее число генерируется на основе суммы квадратов пар чисел. Каждое значение хранит полный путь операций, которые привели к его генерации. Ниже приведены описания реализованных методов.

**Метод `iterate(values_n: list, list_n: list)`**

  Генерирует следующую итерацию последовательности для заданного списка чисел.  

  *Входные параметры:*  
  - `values_n`: список списков, где каждый внутренний список содержит значения последовательности на конкретной итерации.  
  - `list_n`: список, содержащий пары `[значение, путь]`, где `значение` — число, а `путь` — последовательность операций (объектов `NumbersStep`), которые к нему привели. 
   
  *Выходные значения:*  
  - Обновленные `values_n` и `list_n`, включающие новую итерацию.  

**Метод `find_intersection(values_a: list, list_a: list, values_b: list, list_b: list)`**

  Ищет пересечение двух последовательностей, итеративно обновляя их до тех пор, пока пересечение не будет найдено.  

  *Входные параметры:* 
  - `values_a` и `values_b`: начальные значения и итерации для двух последовательностей.  
  - `list_a` и `list_b`: списки пар `[значение, путь]` для каждой последовательности.  

  *Выходное значение:*  
  - Кортеж `(min_path_a, min_path_b)` — пути до первого пересечения для последовательностей `a` и `b`.  

**Метод `get_path(a: int, b: int) -> NumbersPath`**  
  Основная функция, которая инициализирует последовательности для чисел `a` и `b` и вызывает поиск пересечения.  

  *Входные параметры:*  
  - `a` и `b`: начальные числа. 

  *Выходное значение:*
  - Объект `NumbersPath`, содержащий:
    - `a` и `b`: исходные числа.  
    - Пути `min_path_a` и `min_path_b` для пересекающегося значения.  
